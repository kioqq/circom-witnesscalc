// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigUInt {
    #[prost(bytes = "vec", tag = "1")]
    pub value_le: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InputNode {
    #[prost(uint32, tag = "1")]
    pub idx: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstantNode {
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<BigUInt>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnoOpNode {
    #[prost(enumeration = "UnoOp", tag = "1")]
    pub op: i32,
    #[prost(uint32, tag = "2")]
    pub a_idx: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuoOpNode {
    #[prost(enumeration = "DuoOp", tag = "1")]
    pub op: i32,
    #[prost(uint32, tag = "2")]
    pub a_idx: u32,
    #[prost(uint32, tag = "3")]
    pub b_idx: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TresOpNode {
    #[prost(enumeration = "TresOp", tag = "1")]
    pub op: i32,
    #[prost(uint32, tag = "2")]
    pub a_idx: u32,
    #[prost(uint32, tag = "3")]
    pub b_idx: u32,
    #[prost(uint32, tag = "4")]
    pub c_idx: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(oneof = "node::Node", tags = "1, 2, 3, 4, 5")]
    pub node: ::core::option::Option<node::Node>,
}
/// Nested message and enum types in `Node`.
pub mod node {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Node {
        #[prost(message, tag = "1")]
        Input(super::InputNode),
        #[prost(message, tag = "2")]
        Constant(super::ConstantNode),
        #[prost(message, tag = "3")]
        UnoOp(super::UnoOpNode),
        #[prost(message, tag = "4")]
        DuoOp(super::DuoOpNode),
        #[prost(message, tag = "5")]
        TresOp(super::TresOpNode),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignalDescription {
    #[prost(uint32, tag = "1")]
    pub offset: u32,
    #[prost(uint32, tag = "2")]
    pub len: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphMetadata {
    #[prost(uint32, repeated, tag = "1")]
    pub witness_signals: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "string, message", tag = "2")]
    pub inputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SignalDescription,
    >,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DuoOp {
    Mul = 0,
    Div = 1,
    Add = 2,
    Sub = 3,
    Pow = 4,
    Idiv = 5,
    Mod = 6,
    Eq = 7,
    Neq = 8,
    Lt = 9,
    Gt = 10,
    Leq = 11,
    Geq = 12,
    Land = 13,
    Lor = 14,
    Shl = 15,
    Shr = 16,
    Bor = 17,
    Band = 18,
    Bxor = 19,
}
impl DuoOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Mul => "Mul",
            Self::Div => "Div",
            Self::Add => "Add",
            Self::Sub => "Sub",
            Self::Pow => "Pow",
            Self::Idiv => "Idiv",
            Self::Mod => "Mod",
            Self::Eq => "Eq",
            Self::Neq => "Neq",
            Self::Lt => "Lt",
            Self::Gt => "Gt",
            Self::Leq => "Leq",
            Self::Geq => "Geq",
            Self::Land => "Land",
            Self::Lor => "Lor",
            Self::Shl => "Shl",
            Self::Shr => "Shr",
            Self::Bor => "Bor",
            Self::Band => "Band",
            Self::Bxor => "Bxor",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Mul" => Some(Self::Mul),
            "Div" => Some(Self::Div),
            "Add" => Some(Self::Add),
            "Sub" => Some(Self::Sub),
            "Pow" => Some(Self::Pow),
            "Idiv" => Some(Self::Idiv),
            "Mod" => Some(Self::Mod),
            "Eq" => Some(Self::Eq),
            "Neq" => Some(Self::Neq),
            "Lt" => Some(Self::Lt),
            "Gt" => Some(Self::Gt),
            "Leq" => Some(Self::Leq),
            "Geq" => Some(Self::Geq),
            "Land" => Some(Self::Land),
            "Lor" => Some(Self::Lor),
            "Shl" => Some(Self::Shl),
            "Shr" => Some(Self::Shr),
            "Bor" => Some(Self::Bor),
            "Band" => Some(Self::Band),
            "Bxor" => Some(Self::Bxor),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnoOp {
    Neg = 0,
    Id = 1,
}
impl UnoOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Neg => "Neg",
            Self::Id => "Id",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Neg" => Some(Self::Neg),
            "Id" => Some(Self::Id),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TresOp {
    TernCond = 0,
}
impl TresOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TernCond => "TernCond",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TernCond" => Some(Self::TernCond),
            _ => None,
        }
    }
}
